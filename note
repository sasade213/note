1.两数之和（easy）
  思路：一次遍历，哈希表存储已遍历过的数字，同时检查target-nums[i]所得的数字是否在哈希表中

2.两数相加（medium）
  思路：设置一个空链表头，一个临时变量计算每一位的和，一个carry代表是否进位，逐步计算即可，最后判断开头是否是1

3.无重复字符的最长子串（medium）
  思路：滑动窗口（双指针），建立一个哈希表，用来记录出现过的字符的位置，慢指针记录滑动窗口的左端，一旦遇到相同的字符则判断是否要改变位置（利用max），
  快指针向前移动，最终结果就是两者之差

4.寻找两个有序数组的中位数（hard）
  思路：二分法，分出左右两个数组，两边的数量相等时，左边的最大值和右边的最小值即为计算中位数所需。边界条件很多，首先考虑两个数组的长短，短者作为nums1。
  其次考虑如何进行二分，因为需要统一数组总长为奇数（此时中位数为单个数）和偶数（此时中位数两个数的均值）的情况，我们用half来表示分到左右两端的数组的长
  度的话（以12和13为例），我们希望12时左右两边均为6，13时左边为7右边为6（为什么要这样取，因为可以将条件统一起来，当长度为奇数时取left_max，为偶数时取
  (left_max+right_min)/2.0），那么half应该取(l1+l2+1)//2。然后考虑如何二分，m1,m2分别表示左右两边数组的长度，那么只要比较m1和m2-1的大小即可，当m1
  小于m2-1时，说明m1必然不是中位数，left=m1+1；否则m1有可能是中位数,right=m1。最后计算left_max和right_min，边界情况是为0和为原数组长度的时候，要单
  独考虑（其实就是设为极限，相当于不考虑）

5.最长回文子串（medium）
  思路：动态规划。dp[i][j]表示第i个字符到第j个字符是否为回文子串，显然dp[i][i]=1。状态转移方程的情况为，如果s[i-1]==s[j-1]且(dp[i+1][j-1]!=0或
  i+1>j-1)，此时dp[i][j]=2+dp[i+1][j-1]，时间复杂度为O(n^2),空间复杂度为O(n^2)
        中心扩展算法。一共有2n-1个中心（包括了abba中两个b之间的间隔），两边扩散求最大值，时间复杂度O(n^2),空间复杂度O(1)
        manacher算法。不会

6.Z字型变换（medium）
  思路：设置t=min(len(s),numRows)个列表，表示每一行加入的字母，找到规律每一列为t个数字，每个斜列为t-2个数字，依次加入对应的列表即可。特殊情况为t=1时
 
7.整数反转（easy）
  思路：每位加入结果后乘10，原数字取对10的余数。特殊情况为数字为0，或越界，或负数
 
8.字符串转整数（medium）
  思路：利用flag和hasnum判断是否有符号和整数，如果已有符号或整数则不能再出现空格或符号，同时防止溢出和空值，并判断最后一个数是不是整数
 
9.回文数（easy）
  思路：双指针
 
10.正则表达式匹配（hard）
  思路：动态规划。如果pattern为空，返回str是否为空；如果pattern长为1，返回str长为1且(pattern和str相等或pattern为.)；如果pattern长大于等于2且第二
  个符号不为*且str第一个符号和patter第一个符号相等或者pattern第一个符号为.，否则返回False；如果pattern长为2且第二个符号为*，首先判断str是否为空且
  str的第一个数和pattern的第一个数是否相等或者pattern第一个数是否为.，如果不是则pattern前两个数只能匹配0个；否则可以匹配零个或多个，分别讨论即可

11.盛水最多的容器（medium）
  思路：双指针，一个在头一个在尾，更短的指针向更长的指针移动一步
  
12.整数转罗马数字（medium）
  思路：哈希，从最大的数字开始逐一相除取余，遇到余数为0则跳过，target减去数字直到是0为止
  
13.罗马数字转整数（easy）
  思路：哈希，如果连续两位在表内则肯定是连续两位，但是要减去第二位，最后一位额外考虑
  
14.最长公共前缀（easy）
  思路：水平扫描即可

15.三数之和（medium）
  思路：排序，双指针，固定一个数i，判断另外两个数的和是否等于target-i，对于重复的情况要考虑并且跳过
  
16.最接近的三数之和（medium）
  思路：排序，双指针，每次更新最接近的数，遇到完全相等则返回，否则最后再返回

17.
  
  
  
  
  
  
  
  
  
  
  
  
  
  
