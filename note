1.两数之和（easy）
  思路：一次遍历，哈希表存储已遍历过的数字，同时检查target-nums[i]所得的数字是否在哈希表中

2.两数相加（medium）
  思路：设置一个空链表头，一个临时变量计算每一位的和，一个carry代表是否进位，逐步计算即可，最后判断开头是否是1

3.无重复字符的最长子串（medium）
  思路：滑动窗口（双指针），建立一个哈希表，用来记录出现过的字符的位置，慢指针记录滑动窗口的左端，一旦遇到相同的字符则判断是否要改变位置（利用max），
  快指针向前移动，最终结果就是两者之差

4.寻找两个有序数组的中位数（hard）
  思路：二分法，分出左右两个数组，两边的数量相等时，左边的最大值和右边的最小值即为计算中位数所需。边界条件很多，首先考虑两个数组的长短，短者作为nums1。
  其次考虑如何进行二分，因为需要统一数组总长为奇数（此时中位数为单个数）和偶数（此时中位数两个数的均值）的情况，我们用half来表示分到左右两端的数组的长
  度的话（以12和13为例），我们希望12时左右两边均为6，13时左边为7右边为6（为什么要这样取，因为可以将条件统一起来，当长度为奇数时取left_max，为偶数时取
  (left_max+right_min)/2.0），那么half应该取(l1+l2+1)//2。然后考虑如何二分，m1,m2分别表示左右两边数组的长度，那么只要比较m1和m2-1的大小即可，当m1
  小于m2-1时，说明m1必然不是中位数，left=m1+1；否则m1有可能是中位数,right=m1。最后计算left_max和right_min，边界情况是为0和为原数组长度的时候，要单
  独考虑（其实就是设为极限，相当于不考虑）

5.最长回文子串（medium）
  思路：动态规划。dp[i][j]表示第i个字符到第j个字符是否为回文子串，显然dp[i][i]=1。状态转移方程的情况为，如果s[i-1]==s[j-1]且(dp[i+1][j-1]!=0或
  i+1>j-1)，此时dp[i][j]=2+dp[i+1][j-1]，时间复杂度为O(n^2),空间复杂度为O(n^2)
        中心扩展算法。一共有2n-1个中心（包括了abba中两个b之间的间隔），两边扩散求最大值，时间复杂度O(n^2),空间复杂度O(1)
        manacher算法。不会

6.Z字型变换（medium）
  思路：设置t=min(len(s),numRows)个列表，表示每一行加入的字母，找到规律每一列为t个数字，每个斜列为t-2个数字，依次加入对应的列表即可。特殊情况为t=1时
 
7.整数反转（easy）
  思路：每位加入结果后乘10，原数字取对10的余数。特殊情况为数字为0，或越界，或负数
 
8.字符串转整数（medium）
  思路：利用flag和hasnum判断是否有符号和整数，如果已有符号或整数则不能再出现空格或符号，同时防止溢出和空值，并判断最后一个数是不是整数
 
9.回文数（easy）
  思路：双指针
 
10.正则表达式匹配（hard）
  思路：动态规划。如果pattern为空，返回str是否为空；如果pattern长为1，返回str长为1且(pattern和str相等或pattern为.)；如果pattern长大于等于2且第二
  个符号不为*且str第一个符号和patter第一个符号相等或者pattern第一个符号为.，否则返回False；如果pattern长为2且第二个符号为*，首先判断str是否为空且
  str的第一个数和pattern的第一个数是否相等或者pattern第一个数是否为.，如果不是则pattern前两个数只能匹配0个；否则可以匹配零个或多个，分别讨论即可

11.盛水最多的容器（medium）
  思路：双指针，一个在头一个在尾，更短的指针向更长的指针移动一步
  
12.整数转罗马数字（medium）
  思路：哈希，从最大的数字开始逐一相除取余，遇到余数为0则跳过，target减去数字直到是0为止
  
13.罗马数字转整数（easy）
  思路：哈希，如果连续两位在表内则肯定是连续两位，但是要减去第二位，最后一位额外考虑
  
14.最长公共前缀（easy）
  思路：水平扫描即可

15.三数之和（medium）
  思路：排序，双指针，固定一个数i，判断另外两个数的和是否等于target-i，对于重复的情况要考虑并且跳过
  
16.最接近的三数之和（medium）
  思路：排序，双指针，每次更新最接近的数，遇到完全相等则返回，否则最后再返回

23.合并k个排序链表（hard）
  思路：1)堆排序，设置一个最小堆，每轮将所有链表的头插入，然后弹出最小堆的头，并将该链表的下一个元素插入其中
       2)归并排序，设置gap每次合并两个链表，直到最后

25.k个一组反转链表（hard）
  思路：1)尾插法，设置pre为该组链表的head前一个，tail为该组链表的最末尾，将pre后一个每次插入到tail之后，直到pre和tail相连
        2)栈，每次压入k个，再弹出，逐个接入即可，注意最后一组少于k个的链表，要在最外层循环时提前接上防止断开，也要防止断开前最后一组未反向
        3)递归

30.串联所有单词的子串（hard）
  思路：错位遍历，以单词长度为依据，分别查看从i=0,0+l,0+2l以及i=1,1+l,1+2l等开头的序列；滑动窗口，即每次检验子串长度大小的窗口；哈希表，构建两个
       哈希表，一个用来记录所有单词及其次数，另一个用来记录字串中的单词及其次数；优化，分三种情况，当完全匹配时，直接以单词长度进行滑动，当出现不匹
       配的单词时，直接从该单词后进行匹配，当单词次数过多时，直接从该单词之后进行匹配
 
32.最长有小括号（hard）
  思路：1)栈：用栈记录左括号的下标，遇到右括号时弹出，如果栈为空，加入右括号的下表，最开始的时候加入-1（目的在于判断是否不连续，当为空时相当于断开
       重新计算，此时应该从现有的右括号开始算起）
       2)两次遍历：分别用left和right对左右括号进行计数，当两者相等时求长度，right更大时清空（断开需要重新计算）；从右侧做相同操作，目的是防止
       "((())"这样的情况出现
 
37.解数独（hard）
  思路：回溯法，首先设置三个矩阵记录行+数字，列+数字，方块+数字分别是否出现，然后使用深度优先搜索进行回溯，判断条件即为三个矩阵对应位置的结果是否是1，
       按行遍历，即如果y=8则x+1,y=0；否则y+1

39.组合总和（medium）
  思路：回溯法，由于可以重复，每次需要记录本次加入的数字的位置，下次加入数字要从这个数字开始，同时在已经大于target时及时break


  
41.缺失的第一个正数（hard）
  思路：用数组的索引来作为哈希表的键；只需要判断数字是否在1-n之间即可；对于每一个满足条件的数，将其移动至i-1索引的位置（注意此步需要循环多次，否则
  会有遗漏，循环的条件为现在的位置的元素满足条件且与其索引位置的元素不相同）；再遍历一遍即可找出元素

44.通配符匹配（hard）
  思路：动态规划。设置一个二维数组，初始状态包括s为空和p为空的情况，当s为空时，p需要为*；当p为空时,s只能为空。转移方程包括两部分，第一部分是s[i]和
       p[j]相等或者p[j]为"?"，此时p[i][j]=p[i-1][j-1]；第二部分是p[j]为"*"，此时p[i][j]=p[i-1][j] or p[i][j-1]

45.跳跃游戏II（hard）
  思路：贪心，每次跳到本次能跳的范围内下一次最远的位置，直到终点
  
52.跳跃游戏（medium）
  思路：贪心，与上题相同，当遇到某个位置的值为0时，返回0，否则返回1


  
  
  
  
  
  
  
  
  
  
  
