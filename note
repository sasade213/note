1.两数之和（easy）
  思路：一次遍历，哈希表存储已遍历过的数字，同时检查target-nums[i]所得的数字是否在哈希表中

2.两数相加（medium）
  思路：设置一个空链表头，一个临时变量计算每一位的和，一个carry代表是否进位，逐步计算即可，最后判断开头是否是1

3.无重复字符的最长子串（medium）
  思路：滑动窗口（双指针），建立一个哈希表，用来记录出现过的字符的位置，慢指针记录滑动窗口的左端，一旦遇到相同的字符则判断是否要改变位置（利用max），
  快指针向前移动，最终结果就是两者之差

4.寻找两个有序数组的中位数（hard）
  思路：二分法，分出左右两个数组，两边的数量相等时，左边的最大值和右边的最小值即为计算中位数所需。边界条件很多，首先考虑两个数组的长短，短者作为nums1。
  其次考虑如何进行二分，因为需要统一数组总长为奇数（此时中位数为单个数）和偶数（此时中位数两个数的均值）的情况，我们用half来表示分到左右两端的数组的长
  度的话（以12和13为例），我们希望12时左右两边均为6，13时左边为7右边为6（为什么要这样取，因为可以将条件统一起来，当长度为奇数时取left_max，为偶数时取
  (left_max+right_min)/2.0），那么half应该取(l1+l2+1)//2。然后考虑如何二分，m1,m2分别表示左右两边数组的长度，那么只要比较m1和m2-1的大小即可，当m1
  小于m2-1时，说明m1必然不是中位数，left=m1+1；否则m1有可能是中位数,right=m1。最后计算left_max和right_min，边界情况是为0和为原数组长度的时候，要单
  独考虑（其实就是设为极限，相当于不考虑）

5.最长回文子串（medium）
  思路：动态规划。dp[i][j]表示第i个字符到第j个字符是否为回文子串，显然dp[i][i]=1。状态转移方程的情况为，如果s[i-1]==s[j-1]且(dp[i+1][j-1]!=0或
  i+1>j-1)，此时dp[i][j]=2+dp[i+1][j-1]，时间复杂度为O(n^2),空间复杂度为O(n^2)   注意要按先行后列的顺序走！！！！！！
        中心扩展算法。一共有2n-1个中心（包括了abba中两个b之间的间隔），两边扩散求最大值，时间复杂度O(n^2),空间复杂度O(1)
        manacher算法。不会

6.Z字型变换（medium）
  思路：设置t=min(len(s),numRows)个列表，表示每一行加入的字母，找到规律每一列为t个数字，每个斜列为t-2个数字，依次加入对应的列表即可。特殊情况为t=1时
 
7.整数反转（easy）
  思路：每位加入结果后乘10，原数字取对10的余数。特殊情况为数字为0，或越界，或负数
 
8.字符串转整数（medium）
  思路：利用flag和hasnum判断是否有符号和整数，如果已有符号或整数则不能再出现空格或符号，同时防止溢出和空值，并判断最后一个数是不是整数
 
9.回文数（easy）
  思路：双指针
 
10.正则表达式匹配（hard）
  思路：动态规划。如果pattern为空，返回str是否为空；如果pattern长为1，返回str长为1且(pattern和str相等或pattern为.)；如果pattern长大于等于2且第二
  个符号不为*且str第一个符号和patter第一个符号相等或者pattern第一个符号为.，否则返回False；如果pattern长为2且第二个符号为*，首先判断str是否为空且
  str的第一个数和pattern的第一个数是否相等或者pattern第一个数是否为.，如果不是则pattern前两个数只能匹配0个；否则可以匹配零个或多个，分别讨论即可

11.盛水最多的容器（medium）
  思路：双指针，一个在头一个在尾，更短的指针向更长的指针移动一步
  
12.整数转罗马数字（medium）
  思路：哈希，从最大的数字开始逐一相除取余，遇到余数为0则跳过，target减去数字直到是0为止
  
13.罗马数字转整数（easy）
  思路：哈希，如果连续两位在表内则肯定是连续两位，但是要减去第二位，最后一位额外考虑
  
14.最长公共前缀（easy）
  思路：水平扫描即可

15.三数之和（medium）
  思路：排序，双指针，固定一个数i，判断另外两个数的和是否等于target-i，对于重复的情况要考虑并且跳过
  
16.最接近的三数之和（medium）
  思路：排序，双指针，每次更新最接近的数，遇到完全相等则返回，否则最后再返回

18.四数之和（medium）
  思路：与三数之和类似，固定两个数，双指针另外两个数，遇到之前已经有相同的需要跳过，同时要保留相同序列的第一个结果，因为有可能所有相同序列都在同一个
       结果中
  
20.有效的括号（easy）
  思路：栈，遇到左括号将右括号入栈，如果遇到右括号判断是否和栈顶元素相同或者栈为空，不相同返回False，否则出栈；最终返回是否为空栈

22.括号生成（medium）
  思路：动态规划。当知道前n-1组括号的所有组合时，我们只需要考虑最后一组括号应该往哪里插入。对于任何一个有效的括号组合来说，最左边的必然是左括号，与
       其相对应的右括号可能在任何位置，这一对括号之间包含l1=0~n-1个括号，之外包含n-1-l1个括号，因此只要遍历0~n-1个括号的所有组合，并在左右加入这一
       组括号即可

23.合并k个排序链表（hard）
  思路：1)堆排序，设置一个最小堆，每轮将所有链表的头插入，然后弹出最小堆的头，并将该链表的下一个元素插入其中
       2)归并排序，设置gap每次合并两个链表，直到最后

25.k个一组反转链表（hard）
  思路：1)尾插法，设置pre为该组链表的head前一个，tail为该组链表的最末尾，将pre后一个每次插入到tail之后，直到pre和tail相连
        2)栈，每次压入k个，再弹出，逐个接入即可，注意最后一组少于k个的链表，要在最外层循环时提前接上防止断开，也要防止断开前最后一组未反向
        3)递归

30.串联所有单词的子串（hard）
  思路：错位遍历，以单词长度为依据，分别查看从i=0,0+l,0+2l以及i=1,1+l,1+2l等开头的序列；滑动窗口，即每次检验子串长度大小的窗口；哈希表，构建两个
       哈希表，一个用来记录所有单词及其次数，另一个用来记录字串中的单词及其次数；优化，分三种情况，当完全匹配时，直接以单词长度进行滑动，当出现不匹
       配的单词时，直接从该单词后进行匹配，当单词次数过多时，直接从该单词之后进行匹配

31.下一个排列（medium）
  思路：从后往前遍历，找到第一个逆序的位置，这个位置就是需要交换的位置，再从这个位置开始扫描，找到正好比这个数字大的数，两者交换，然后对逆序位置后的
       所有数组进行排序

32.最长有小括号（hard）
  思路：1)栈：用栈记录左括号的下标，遇到右括号时弹出，如果栈为空，加入右括号的下表，最开始的时候加入-1（目的在于判断是否不连续，当为空时相当于断开
       重新计算，此时应该从现有的右括号开始算起）
       2)两次遍历：分别用left和right对左右括号进行计数，当两者相等时求长度，right更大时清空（断开需要重新计算）；从右侧做相同操作，目的是防止
       "((())"这样的情况出现
 
37.解数独（hard）
  思路：回溯法，首先设置三个矩阵记录行+数字，列+数字，方块+数字分别是否出现，然后使用深度优先搜索进行回溯，判断条件即为三个矩阵对应位置的结果是否是1，
       按行遍历，即如果y=8则x+1,y=0；否则y+1

39.组合总和（medium）
  思路：回溯法，由于可以重复，每次需要记录本次加入的数字的位置，下次加入数字要从这个数字开始，同时在已经大于target时及时break

40.组合总和II（medium）
  思路：回溯法，与上一题相同，需要加入判断是否重复的语句，思想在于如果两个区间一大一小，那么大区间的组合一定包含小区间的组合，因此只要排序后将重复
       部分跳过即可
  
41.缺失的第一个正数（hard）
  思路：用数组的索引来作为哈希表的键；只需要判断数字是否在1-n之间即可；对于每一个满足条件的数，将其移动至i-1索引的位置（注意此步需要循环多次，否则
  会有遗漏，循环的条件为现在的位置的元素满足条件且与其索引位置的元素不相同）；再遍历一遍即可找出元素

44.通配符匹配（hard）
  思路：动态规划。设置一个二维数组，初始状态包括s为空和p为空的情况，当s为空时，p需要为*；当p为空时,s只能为空。转移方程包括两部分，第一部分是s[i]和
       p[j]相等或者p[j]为"?"，此时p[i][j]=p[i-1][j-1]；第二部分是p[j]为"*"，此时p[i][j]=p[i-1][j] or p[i][j-1]

45.跳跃游戏II（hard）
  思路：贪心，每次跳到本次能跳的范围内下一次最远的位置，直到终点

46.全排列（medium）
  思路：回溯法。每次将开始位置和后序的某个位置交换，如果开始位置达到n则停止
  
47.全排列II（medium）
  思路：回溯法。区别在于判断重复，方法是当某个数在这个数之前的数组出现过，则跳过

52.N皇后II（hard）
  思路：全排列，判断是否满足条件，注意结果的传值和传引用

54.螺旋矩阵（medium）
  思路：每次打印最外圈，最大的圈数*2应该小于行数和列数（不能等于）。对于最后一圈，需要考虑边界条件（也就是最后为一横、一列或一个2*2矩阵的情况）
       每圈的上边可以直接打印，右边要保证不能是一横，因此要保证start<endy，下边要保证不能为一横或一列，因此要保证start<end and start<endy，
       左边要保证必须大于2行且大于1列，因此要保证start<endx and start<endy-1

55.跳跃游戏（medium）
  思路：贪心，与上题相同，当遇到某个位置的值为0时，返回0，否则返回1

57.插入区间（hard）
  思路：找到与给出区间有重叠的部分。从左往右遍历，如果现区间的右端点小于目标区间的左端点，则无重叠，可直接加入；遇到第一个大于时，break，记录该位置
       的值；继续遍历，如果现区间的左端点的值大于目标区间的右端点，则断开，现区间的前一个区间为重叠部分的终点；头部的左端与目标区间的左端的较小值，
       尾部右端与目标区间右端的较大值合并为一个区间（特殊情况：目标区间无任何重叠，在最左端，最右端或者两个区间之间）

76.最小覆盖子串（hard）
  思路：滑动窗口。首先记录模式串中各个字母出现的次数，其余次数计为0，保存在哈希表中；然后遍历字符串，遇到还未消耗的模式字母则字典-1，长度-1，长度
       到达0表示完全遍历，此时的位置表示滑动窗口的右端；下一步缩小左端，对于每个遇到的字母，字典内容+1，直到该字母在字典中的计数为0时，表示正好，
       此时记录左右两端的位置（注意！！！！！！！！！！！返回的是字符串，所以在记录位置时提前对end+1，否则在结果中遇到"a","a"等特殊情况会出错）

84.柱状图最大矩形（hard）
  思路：使用栈，每次计算的是以某个位置的值为高的矩形的最大面积，该面积可以用高*左右两边第一个小于它的值的差来计算。如此便可使用栈，首先将-1压入表示
       左边有一个高度为0的条块，在整个数组右边加入0表示右边有一个高度为0的条块，遍历过程中遇到小于栈定元素时，弹出栈顶元素并计算以栈顶元素为高的
       矩形的最大面积，宽度为i-stack[-1]-1，减一是因为不包含stack[-1]这个值

85.最大矩形（hard）
  思路：将每一行作为底，向上计算柱状图最大矩形即可，当底为0则整体为0，否则为上一行的底加上1

87.扰乱字符串（hard）
  思路：递归。共分为两种情况，第一种是对原始字符串切分后经过若干步交换得到目标字符串，另一种是原始字符串经过切分后先交换一步，再经过若干步交换得到
       切分字符串；分别对每一个位置进行切分并递归，比较是否是扰乱字符串即可

97.交错字符串（hard）
  思路：动态规划。dp[i][j]表示s1的前i个字母和s2的前j个字母是否是s3前i-j个字母的交错字符串；状态转移方程为s1的前i-1个字母和s2的前j个字母是否为s3
       的前i+j-1个字母的交错字符串且s1的第i个字母和s3的第i+j个字母是否相等或者为s2的前i个字母和s2的前j-1个字母是否为s3的前i+j-1个字母的交错字符
       串且s2的第j个字母和s3的第i+j个字母是否相等

99.恢复二叉搜索树（hard）
  思路：只能做到O(n)的空间复杂度。中序遍历二叉搜索树，得到的结果应该是递增的，找出第一个反序的节点并记录，再找到第二个反序的节点，两者的值交换

101.对称的二叉树（easy）
思路：递归。出口条件是首先如果左右子树均为空则为1，只有一个为空或者两边值不相等则为0，否则判断左子树的左子树和右子树的右子树是否对称，以及左子树的
     右子树和右子树的左子树是否对称。

154.旋转数组的最小数字II（hard）
  思路：二分法，关键在于mid==right时的判断，此处使用right=right-1。原理是当mid==right时，mid左边的数必然等于right，所以如果right是最小值，这样
       不会错过最小值；如果right不是最小值，那么right-1的过程中必然会遇到最小值，left=mid+1，同样不会错过

392.判断子序列（medium）
  思路：使用迭代器表示长序列，使用all判断是否所有的短序列字符存在于长序列中

572.另一个树的子树（easy）
  思路：递归，判断是否为子树共分三种情况，一种是左子树的子树，一种是右子树的子树，一种是根节点相同，判断左右两边是否是子树，需要定义新函数判断


       
  
  
  
  
  
  
  
  
